
#define M_PI 3.1415

vec2 Rot2D(vec2 q, float a)
{
  vec2 cs;
  cs = sin (a + vec2 (0.5 * M_PI, 0.));
  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));
}

float PrBoxDf(vec3 p, vec3 b)
{
  vec3 d;
  d = abs (p) - b;
  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));
}

float de1(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}


float de2(vec3 p)
{
  vec3 b;
  float r, a;
  const float nIt = 5., sclFac = 2.4;
  b = (sclFac - 1.) * vec3 (1., 1.125, 0.625);
  r = length (p.xz);
  a = (r > 0.) ? atan (p.z, - p.x) / (2. * M_PI) : 0.;
  p.y = mod (p.y - 4. * a + 2., 4.) - 2.;
  p.x = mod (16. * a + 1., 2.) - 1.;
  p.z = r - 32. / (2. * M_PI);
  p.yz = Rot2D (p.yz, 2. * M_PI * a);
  for (float n = 0.; n < nIt; n ++) {
    p = abs (p);
    p.xy = (p.x > p.y) ? p.xy : p.yx;
    p.xz = (p.x > p.z) ? p.xz : p.zx;
    p.yz = (p.y > p.z) ? p.yz : p.zy;
    p = sclFac * p - b;
    p.z += b.z * step (p.z, -0.5 * b.z);
  }
  return 0.8 * PrBoxDf (p, vec3 (1.)) / pow (sclFac, nIt);
}


int hittype = 0;

float de(vec3 p){

	hittype = 0;

	float d1 = 1.618*de2(p/1.618);
	
	p.y += 8.;
	float d2 = de1(p);
	p.y -= 4.;
	float d3 = de1(p);
	p.y -= 4.;
	float d4 = de1(p);
	p.y -= 4.;
	float d5 = de1(p);
	p.y -= 4.;
	float d6 = de1(p);

	float d = min(d1,min(d2, min(d3, min(d4, min(d5, d6)))));

	if(d==d1)
		hittype = 1;
	else if(d==d2)
		hittype = 2;
	else if(d==d3)
		hittype = 3;
	else if(d==d4)
		hittype = 4;
	else if(d==d5)
		hittype = 5;
	else if(d==d6)
		hittype = 6;
	else
		hittype = 0;

	return d;
}


#define EPSILON   0.2
vec3 norm(vec3 p) { // to get the normal vector for a point in space, this function evaluates the gradient of the distance function
#define METHOD 2
#if METHOD == 0 
    // tetrahedron version, unknown source - 4 evaluations
    vec2 e = vec2(1,-1) * EPSILON;
    return normalize(e.xyy*de(p+e.xyy)+e.yyx*de(p+e.yyx)+e.yxy*de(p+e.yxy)+e.xxx*de(p+e.xxx));

#elif METHOD == 1
    // by iq = more efficient, 4 evaluations
    vec2 e = vec2( EPSILON, 0.); // computes the gradient of the estimator function
    return normalize( vec3(de(p)) - vec3( de(p-e.xyy), de(p-e.yxy), de(p-e.yyx) ));

#elif METHOD == 2
    // by iq - less efficient, 6 evaluations
    vec3 eps = vec3(EPSILON,0.0,0.0);
    return normalize( vec3(
                          de(p+eps.xyy) - de(p-eps.xyy),
                          de(p+eps.yxy) - de(p-eps.yxy),
                          de(p+eps.yyx) - de(p-eps.yyx)));
#endif
}


float calcAO( in vec3 pos, in vec3 nor )
{
    float occ = 0.0;
    float sca = 1.0;
    for( int i=0; i<5; i++ )
    {
        float h = 0.001 + 0.15*float(i)/4.0;
        float d = de( pos + h*nor );
        occ += (h-d)*sca;
        sca *= 0.95;
    }
    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );
}



irec is_inside(){  // check Documentation tab for details 

 irec temp;
 
 float scalar = 11.;
 myloc *= scalar;

 temp.draw  = false;   // is this voxel's value going to change?
 temp.color = vec4(0); // what should its color be?
 temp.mask  = 0;       // how much do you wish to mask?

int hitcount = 0;
for(int i = 0; i < 64; i++){
	vec3 pos = myloc + 0.618 * scalar * off * blue(ivec2(i*int(myloc.x))).xyz;
	if(de(pos) < 0.){
		temp.draw = true;
		//temp.color = vec4((0.5*norm(myloc))+vec3(0.5),0.75);
		
		
		switch(hittype){
			case 1:
			temp.color.xyz += vec3(1,0.2,0)*calcAO(pos,norm(pos));
			break;
			
			case 2:
			temp.color.xyz += vec3(111./255., 45./255., 189./255.)*calcAO(pos,norm(pos));
			break;

			case 3:
			temp.color.xyz += vec3(166./255., 99./255., 204./255.)*calcAO(pos,norm(pos));
			break;

			case 4:
			temp.color.xyz += vec3(178./255., 152./255., 220./255.)*calcAO(pos,norm(pos));
			break;

			case 5:
			temp.color.xyz += vec3(184./255., 208./255., 235./255.)*calcAO(pos,norm(pos));
			break;

			case 6:
			temp.color.xyz += vec3(185./255., 250./255., 248./255.)*calcAO(pos,norm(pos));
			break;

			default:
			temp.color.xyz += vec3(1)*calcAO(pos,norm(pos));
			break;
		}
		temp.color.a += 0.95;
		hitcount++;
	}
}

if(hitcount > 0)
	temp.color.rgba /= float(hitcount);
//temp.color = vec4(vec3(0.5*hitcount), 0.75);

 return temp;

}

